{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-2477238081b184613fd4dd106663b06c39256850",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/ShXRPVault.sol": "project/contracts/ShXRPVault.sol",
    "contracts/VaultController.sol": "project/contracts/VaultController.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/AccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/access/IAccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/draft-IERC6093.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC4626.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC4626.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/ERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/ERC4626.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";\nimport {SafeERC20} from \"../utils/SafeERC20.sol\";\nimport {IERC4626} from \"../../../interfaces/IERC4626.sol\";\nimport {Math} from \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _underlyingDecimals;\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }\n\n    /// @inheritdoc IERC4626\n    function asset() public view virtual returns (address) {\n        return address(_asset);\n    }\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(IERC20(asset()), receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Panic.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Pausable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/interfaces/IStrategy.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IStrategy\n * @dev Standard interface for yield strategies in ShXRP Vault\n * \n * Architecture:\n * - ShXRPVault holds multiple strategies implementing this interface\n * - Each strategy manages a portion of vault's FXRP capital\n * - Vault calls deploy() to allocate capital, withdraw() to retrieve it\n * - totalAssets() returns FXRP-equivalent value for vault accounting\n * \n * Compatible Strategies:\n * - KineticStrategy: FXRP lending on Kinetic Markets (~5-6% APY)\n * - FirelightStrategy: FXRP → stXRP liquid staking (when protocol matures)\n * - Future: SparkDEX LP, Enosys Loans, etc.\n * \n * Security Notes:\n * - Only vault contract should call deploy/withdraw\n * - Strategies must return accurate totalAssets() for share price calculation\n * - Failed operations should revert (not return false)\n */\ninterface IStrategy {\n    \n    /**\n     * @dev Returns the underlying asset (FXRP token address)\n     * \n     * All strategies must use FXRP as the base asset to maintain\n     * compatibility with ShXRPVault's ERC-4626 implementation.\n     * \n     * @return address FXRP token address\n     * \n     * Example:\n     * return 0xAd552A648C74D49E10027AB8a618A3ad4901c5bE; // FXRP Mainnet\n     */\n    function asset() external view returns (address);\n    \n    /**\n     * @dev Calculate total FXRP-equivalent value held by this strategy\n     * \n     * Critical Function:\n     * - Used by ShXRPVault.totalAssets() for share price calculation\n     * - Must return accurate FXRP value including accrued yield\n     * - Should handle edge cases (zero deposits, protocol paused, etc.)\n     * \n     * Implementation Guide:\n     * - For lending: Query deposited balance + accrued interest\n     * - For staking: Convert staked tokens to FXRP using oracle/exchange rate\n     * - For LP: Value LP tokens in FXRP terms\n     * \n     * Example (Kinetic lending):\n     * ```\n     * return kineticPool.balanceOfUnderlying(address(this));\n     * ```\n     * \n     * Example (Firelight staking with oracle):\n     * ```\n     * uint256 stXRPBalance = stXRPToken.balanceOf(address(this));\n     * uint256 stXRPPrice = oracle.getPrice(\"stXRP/FXRP\");\n     * return (stXRPBalance * stXRPPrice) / 1e18;\n     * ```\n     * \n     * @return Total FXRP-equivalent assets in strategy (6 decimals)\n     */\n    function totalAssets() external view returns (uint256);\n    \n    /**\n     * @dev Deploy FXRP capital to this strategy\n     * \n     * Called by:\n     * - ShXRPVault.deployToStrategy(strategyAddress, amount)\n     * - Rebalancing keeper when buffer exceeds target\n     * \n     * CRITICAL: Pull-Based Pattern\n     * - Vault approves FXRP for strategy before calling deploy()\n     * - Strategy MUST pull FXRP from vault using transferFrom\n     * - This prevents double-counting in vault.totalAssets()\n     * \n     * Requirements:\n     * - Caller must be vault contract\n     * - Vault must have approved FXRP transfer beforehand\n     * - Strategy must pull exactly the approved amount\n     * - Amount must be > 0\n     * \n     * Implementation Steps:\n     * 1. Pull FXRP from vault using transferFrom(msg.sender, address(this), amount)\n     * 2. Deposit FXRP into underlying protocol (Kinetic, Firelight, etc.)\n     * 3. Track position (update internal accounting)\n     * 4. Emit DeployedToStrategy event\n     * \n     * Example (Kinetic):\n     * ```\n     * // Pull FXRP from vault (vault has already approved)\n     * IERC20(fxrp).transferFrom(msg.sender, address(this), amount);\n     * \n     * // Deploy to Kinetic protocol\n     * IERC20(fxrp).approve(kineticPool, amount);\n     * kineticPool.supply(amount);\n     * \n     * emit DeployedToStrategy(amount);\n     * ```\n     * \n     * @param amount Amount of FXRP to deploy (6 decimals)\n     */\n    function deploy(uint256 amount) external;\n    \n    /**\n     * @dev Withdraw FXRP from this strategy\n     * \n     * Called by:\n     * - ShXRPVault.withdrawFromStrategy(strategyAddress, amount)\n     * - User withdrawal when buffer is insufficient\n     * - Rebalancing keeper when strategy allocation too high\n     * \n     * Requirements:\n     * - Caller must be vault contract\n     * - Amount must be <= totalAssets()\n     * - Receiver must be valid address\n     * \n     * Implementation Steps:\n     * 1. Redeem position from underlying protocol\n     * 2. Receive FXRP (may include accrued yield)\n     * 3. Transfer FXRP to receiver (usually vault)\n     * 4. Update internal accounting\n     * 5. Emit WithdrawnFromStrategy event\n     * \n     * Edge Cases:\n     * - If protocol has withdrawal delay (e.g., Firelight unstaking):\n     *   * Strategy should handle async withdrawals\n     *   * May need to revert with \"Withdrawal pending\" error\n     * - If amount > available liquidity:\n     *   * Withdraw maximum available\n     *   * Or revert if exact amount required\n     * \n     * Example (Kinetic):\n     * ```\n     * uint256 fxrpReceived = kineticPool.withdraw(amount);\n     * IERC20(fxrp).transfer(receiver, fxrpReceived);\n     * emit WithdrawnFromStrategy(amount, fxrpReceived);\n     * ```\n     * \n     * @param amount Amount of FXRP to withdraw (6 decimals)\n     * @param receiver Address to receive withdrawn FXRP (usually vault)\n     * @return actualAmount Actual FXRP withdrawn (may differ due to fees/slippage)\n     */\n    function withdraw(uint256 amount, address receiver) external returns (uint256 actualAmount);\n    \n    /**\n     * @dev Report strategy performance and update state\n     * \n     * Called by:\n     * - Vault periodically (e.g., daily via keeper)\n     * - Before rebalancing operations\n     * - After major vault operations (large deposit/withdrawal)\n     * \n     * Purpose:\n     * - Claim/compound rewards if applicable\n     * - Update internal state (cached balances, exchange rates, etc.)\n     * - Calculate performance metrics (APY, total return, etc.)\n     * - Emit performance data for off-chain tracking\n     * \n     * Implementation Example (Kinetic):\n     * ```\n     * uint256 previousBalance = lastReportedBalance;\n     * uint256 currentBalance = kineticPool.balanceOfUnderlying(address(this));\n     * uint256 profit = currentBalance - previousBalance;\n     * \n     * lastReportedBalance = currentBalance;\n     * totalProfit += profit;\n     * \n     * emit StrategyReport(currentBalance, profit, block.timestamp);\n     * ```\n     * \n     * Return Values:\n     * - profit: FXRP gained since last report\n     * - loss: FXRP lost (if any - should be rare)\n     * - totalAssets: Current total FXRP value\n     * \n     * @return profit FXRP gained since last report (6 decimals)\n     * @return loss FXRP lost since last report (6 decimals)\n     * @return totalAssets Current total FXRP-equivalent value (6 decimals)\n     */\n    function report() external returns (\n        uint256 profit,\n        uint256 loss,\n        uint256 totalAssets\n    );\n    \n    /**\n     * @dev Check if strategy is active and accepting deposits\n     * \n     * Useful for:\n     * - Vault to check before deploying capital\n     * - UI to show strategy status\n     * - Emergency pause mechanism\n     * \n     * Should return false if:\n     * - Strategy is paused by owner\n     * - Underlying protocol is paused/deprecated\n     * - Strategy reached max capacity\n     * - Critical error detected\n     * \n     * @return true if strategy is operational and can accept deposits\n     */\n    function isActive() external view returns (bool);\n    \n    /**\n     * @dev Get strategy name for identification\n     * \n     * Used by:\n     * - Vault for logging/events\n     * - UI for display\n     * - Analytics for tracking\n     * \n     * Examples:\n     * - \"Kinetic FXRP Lending\"\n     * - \"Firelight stXRP Staking\"\n     * - \"SparkDEX FXRP/USDT0 LP\"\n     * \n     * @return Strategy name as string\n     */\n    function name() external view returns (string memory);\n    \n    // ========================================\n    // EVENTS\n    // ========================================\n    \n    /**\n     * @dev Emitted when FXRP is deployed to strategy\n     * @param amount FXRP amount deployed\n     */\n    event DeployedToStrategy(uint256 amount);\n    \n    /**\n     * @dev Emitted when FXRP is withdrawn from strategy\n     * @param amount FXRP amount requested\n     * @param actualAmount Actual FXRP withdrawn\n     */\n    event WithdrawnFromStrategy(uint256 amount, uint256 actualAmount);\n    \n    /**\n     * @dev Emitted when strategy reports performance\n     * @param profit FXRP gained since last report\n     * @param loss FXRP lost since last report\n     * @param totalAssets Current total FXRP value\n     */\n    event StrategyReport(uint256 profit, uint256 loss, uint256 totalAssets);\n}\n"
      },
      "project/contracts/ShXRPVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IStrategy.sol\";\n\n/**\n * @title Shield XRP Vault (shXRP)\n * @dev ERC-4626 compliant tokenized vault for XRP on Flare Network\n * \n * Architecture:\n * - Asset: FXRP (FAssets-wrapped XRP on Flare Network)\n * - Shares: shXRP (liquid staking token, ERC-20 compliant)\n * - Standard: ERC-4626 (Tokenized Vault Standard)\n * \n * Features:\n * - Deposit FXRP → Receive shXRP shares (automatic exchange rate)\n * - Redeem shXRP → Receive FXRP (proportional to vault performance)\n * - Operator-controlled for bridging coordination\n * - Multi-strategy yield optimization (Kinetic lending, Firelight staking, etc.)\n * - Dynamic buffer management for instant withdrawals\n * - ReentrancyGuard for deposit/withdrawal security\n * - Pausable for emergency stop (exploit/vulnerability protection)\n * - Deposit limit enforcement to control TVL growth\n * \n * Flow:\n * 1. User mints FXRP via FAssets bridge (XRP → FXRP on Flare)\n * 2. User approves FXRP spending for this vault\n * 3. User calls deposit() with FXRP amount → Receives shXRP shares\n * 4. Vault holds buffer (10%) + deploys capital to strategies (90%)\n * 5. Strategies generate yield (Kinetic ~5-6%, Firelight higher when ready)\n * 6. shXRP value increases as strategies generate returns\n * 7. User calls withdraw() with shXRP → Receives FXRP from buffer + accrued yield\n * \n * ERC-4626 Benefits:\n * - Standard interface for all DeFi integrations\n * - Automatic share price calculation (no manual exchange rate)\n * - Compatible with lending protocols, DEXs, aggregators\n * - Transparent vault accounting via totalAssets()\n * \n * Integration Notes:\n * - FXRP: See docs/FLARE_FASSETS_INTEGRATION.md\n * - Strategies: See docs/STRATEGY_INTEGRATION.md\n * - Operators coordinate bridging between XRPL and Flare\n */\ncontract ShXRPVault is ERC4626, Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n    \n    // ========================================\n    // ENUMS & STRUCTS\n    // ========================================\n    \n    enum StrategyStatus {\n        Inactive,      // Strategy not yet activated\n        Active,        // Strategy operational and receiving deposits\n        Paused,        // Temporarily paused (can be resumed)\n        Deprecated     // Permanently disabled (being phased out)\n    }\n    \n    struct StrategyInfo {\n        address strategyAddress;    // IStrategy contract address\n        uint256 targetBps;           // Target allocation in basis points (10000 = 100%)\n        StrategyStatus status;       // Current operational status\n        uint256 totalDeployed;       // Total FXRP deployed to this strategy\n        uint256 lastReportTimestamp; // Last time strategy.report() was called\n    }\n    \n    // ========================================\n    // STATE VARIABLES\n    // ========================================\n    \n    // Revenue Router for automatic fee distribution (buyback & burn)\n    address public immutable revenueRouter;\n    \n    // Fee Configuration (in basis points, 10000 = 100%)\n    uint256 public constant DEPOSIT_FEE_BPS = 20;  // 0.2% deposit fee\n    uint256 public constant WITHDRAW_FEE_BPS = 20; // 0.2% withdraw fee\n    uint256 public yieldRoutingFeeBps = 10;        // 0.1% yield routing fee (adjustable)\n    \n    // Mapping of approved operators who can manage strategies\n    mapping(address => bool) public operators;\n    \n    // Minimum deposit amount (0.01 FXRP with 6 decimals)\n    uint256 public minDeposit = 10000; // 0.01 FXRP (6 decimals)\n    \n    // Maximum total deposit limit (prevents uncontrolled TVL growth)\n    // Start with 1M FXRP (~$2.1M at $2.10/XRP), can be increased as strategies scale\n    uint256 public depositLimit = 1_000_000e6; // 1,000,000 FXRP (6 decimals)\n    \n    // Strategy Management\n    mapping(address => StrategyInfo) public strategies;\n    address[] public strategyList;\n    uint256 public totalStrategyTargetBps; // Sum of all strategy targetBps (for validation)\n    \n    // Buffer Management (for instant withdrawals)\n    uint256 public bufferTargetBps = 1000; // 10% target buffer (10000 = 100%)\n    \n    // ========================================\n    // EVENTS\n    // ========================================\n    \n    event OperatorAdded(address indexed operator);\n    event OperatorRemoved(address indexed operator);\n    event MinDepositUpdated(uint256 newMinDeposit);\n    event BufferTargetUpdated(uint256 newTargetBps);\n    event DepositLimitUpdated(uint256 newDepositLimit);\n    event YieldRoutingFeeUpdated(uint256 newFeeBps);\n    event FeeTransferred(string indexed feeType, uint256 amount, address indexed recipient);\n    \n    // Strategy Events\n    event StrategyAdded(address indexed strategy, uint256 targetBps);\n    event StrategyRemoved(address indexed strategy);\n    event StrategyStatusUpdated(address indexed strategy, StrategyStatus newStatus);\n    event StrategyAllocationUpdated(address indexed strategy, uint256 newTargetBps);\n    event DeployedToStrategy(address indexed strategy, uint256 amount);\n    event WithdrawnFromStrategy(address indexed strategy, uint256 amount, uint256 actualAmount);\n    event StrategyReported(address indexed strategy, uint256 profit, uint256 loss, uint256 totalAssets);\n    \n    modifier onlyOperator() {\n        require(operators[msg.sender] || msg.sender == owner(), \"Not authorized\");\n        _;\n    }\n    \n    /**\n     * @dev Constructor\n     * @param _fxrpToken Address of FXRP token (FAssets-wrapped XRP)\n     * @param _name Name of the share token (e.g., \"Shield XRP\")\n     * @param _symbol Symbol of the share token (e.g., \"shXRP\")\n     * @param _revenueRouter Address of RevenueRouter for fee distribution\n     * \n     * Example deployment:\n     * FXRP Mainnet: 0xAd552A648C74D49E10027AB8a618A3ad4901c5bE\n     * FXRP Coston2: 0xa3Bd00D652D0f28D2417339322A51d4Fbe2B22D3\n     */\n    constructor(\n        IERC20 _fxrpToken,\n        string memory _name,\n        string memory _symbol,\n        address _revenueRouter\n    ) ERC4626(_fxrpToken) ERC20(_name, _symbol) Ownable(msg.sender) {\n        require(address(_fxrpToken) != address(0), \"Invalid FXRP token address\");\n        require(_revenueRouter != address(0), \"Invalid revenue router address\");\n        \n        revenueRouter = _revenueRouter;\n        \n        // Deployer is first operator\n        operators[msg.sender] = true;\n        emit OperatorAdded(msg.sender);\n    }\n    \n    /**\n     * @dev Override decimals to match the underlying FXRP asset (6 decimals)\n     * \n     * OpenZeppelin ERC20 defaults to 18 decimals, but FXRP uses 6.\n     * This ensures all ERC4626 math (convertToShares, convertToAssets, etc.)\n     * works correctly with 6-decimal FXRP values.\n     * \n     * @return uint8 Number of decimals (inherited from FXRP)\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return IERC20Metadata(address(asset())).decimals();\n    }\n    \n    /**\n     * @dev Override maxDeposit to enforce deposit limit\n     * \n     * ERC4626 Compliance (Critical):\n     * Preview functions must reflect the deposit limit, otherwise integrators\n     * (DEXs, aggregators, wallets) will show incorrect max deposit amounts.\n     * \n     * Standard Behavior:\n     * - Returns remaining capacity: depositLimit - totalAssets()\n     * - Returns 0 if at or above limit\n     * - Returns 0 if paused\n     * \n     * Example:\n     * - Deposit limit: 1M FXRP\n     * - Current TVL: 750K FXRP\n     * - maxDeposit() returns: 250K FXRP (remaining capacity)\n     * \n     * @return Maximum amount of assets that can be deposited\n     */\n    function maxDeposit(address /* receiver */) public view virtual override returns (uint256) {\n        // If paused, no deposits allowed\n        if (paused()) {\n            return 0;\n        }\n        \n        uint256 currentAssets = totalAssets();\n        \n        // If at or above limit, no deposits allowed\n        if (currentAssets >= depositLimit) {\n            return 0;\n        }\n        \n        // Return remaining capacity\n        return depositLimit - currentAssets;\n    }\n    \n    /**\n     * @dev Override maxMint to enforce deposit limit\n     * \n     * ERC4626 Compliance (Critical):\n     * Shares-based preview must also respect deposit limit.\n     * \n     * Calculation:\n     * 1. Get remaining capacity in assets (depositLimit - totalAssets())\n     * 2. Convert to shares using current exchange rate\n     * \n     * @return Maximum amount of shares that can be minted\n     */\n    function maxMint(address /* receiver */) public view virtual override returns (uint256) {\n        // If paused, no mints allowed\n        if (paused()) {\n            return 0;\n        }\n        \n        uint256 currentAssets = totalAssets();\n        \n        // If at or above limit, no mints allowed\n        if (currentAssets >= depositLimit) {\n            return 0;\n        }\n        \n        // Get remaining capacity in assets\n        uint256 remainingAssets = depositLimit - currentAssets;\n        \n        // Convert to shares using current exchange rate\n        return _convertToShares(remainingAssets, Math.Rounding.Floor);\n    }\n    \n    /**\n     * @dev Calculate total assets under management\n     * \n     * ERC-4626 Required Function\n     * This drives the share price calculation:\n     * Share Price = totalAssets() / totalSupply()\n     * \n     * Assets Include:\n     * 1. FXRP held directly in vault (buffer for instant withdrawals)\n     * 2. FXRP deployed to active strategies (earning yield)\n     * \n     * As strategies generate yield, totalAssets() increases,\n     * automatically increasing the value of shXRP shares.\n     * \n     * Strategy Safety:\n     * - Uses try/catch for each strategy.totalAssets() call\n     * - If a strategy fails, uses its totalDeployed as fallback\n     * - Ensures totalAssets() never reverts (critical for ERC-4626)\n     * \n     * @return Total FXRP-equivalent assets in the vault\n     */\n    function totalAssets() public view virtual override returns (uint256) {\n        // Start with FXRP buffer (instant withdrawal reserve)\n        uint256 total = IERC20(asset()).balanceOf(address(this));\n        \n        // Add value from all active strategies\n        for (uint256 i = 0; i < strategyList.length; i++) {\n            address strategyAddr = strategyList[i];\n            StrategyInfo storage strategyInfo = strategies[strategyAddr];\n            \n            // Only count Active strategies\n            if (strategyInfo.status != StrategyStatus.Active) {\n                continue;\n            }\n            \n            // Query strategy's total assets with fallback protection\n            try IStrategy(strategyAddr).totalAssets() returns (uint256 strategyAssets) {\n                total += strategyAssets;\n            } catch {\n                // If strategy fails, use totalDeployed as conservative estimate\n                // This prevents single strategy failure from breaking entire vault\n                total += strategyInfo.totalDeployed;\n            }\n        }\n        \n        return total;\n    }\n    \n    /**\n     * @dev Deposit FXRP and receive shXRP shares\n     * \n     * Overrides ERC-4626 deposit to add:\n     * - Minimum deposit enforcement\n     * - Reentrancy protection\n     * \n     * Standard ERC-4626 Flow:\n     * 1. User approves FXRP spending: fxrp.approve(vault, amount)\n     * 2. User calls deposit(amount, receiver)\n     * 3. Vault transfers FXRP from user\n     * 4. Vault mints shXRP shares to receiver\n     * \n     * Share Calculation (automatic):\n     * shares = (assets * totalSupply()) / totalAssets()\n     * \n     * @param assets Amount of FXRP to deposit\n     * @param receiver Address to receive shXRP shares\n     * @return shares Amount of shXRP shares minted\n     */\n    function deposit(uint256 assets, address receiver) \n        public \n        virtual \n        override \n        nonReentrant \n        whenNotPaused \n        returns (uint256) \n    {\n        require(assets >= minDeposit, \"Below minimum deposit\");\n        return super.deposit(assets, receiver);\n    }\n    \n    /**\n     * @dev Mint exact amount of shXRP shares\n     * \n     * Overrides ERC-4626 mint to add:\n     * - Minimum deposit enforcement (via asset preview)\n     * - Reentrancy protection\n     * \n     * Use Case:\n     * When user wants exact number of shares, not exact FXRP amount\n     * \n     * @param shares Amount of shXRP shares to mint\n     * @param receiver Address to receive shXRP shares\n     * @return assets Amount of FXRP deposited\n     */\n    function mint(uint256 shares, address receiver) \n        public \n        virtual \n        override \n        nonReentrant \n        whenNotPaused \n        returns (uint256) \n    {\n        uint256 assets = previewMint(shares);\n        require(assets >= minDeposit, \"Below minimum deposit\");\n        return super.mint(shares, receiver);\n    }\n    \n    /**\n     * @dev Withdraw FXRP by burning shXRP shares\n     * \n     * Adds reentrancy protection to standard ERC-4626 withdraw\n     * \n     * Standard ERC-4626 Flow:\n     * 1. User calls withdraw(assets, receiver, owner)\n     * 2. Vault burns shXRP from owner\n     * 3. Vault transfers FXRP to receiver\n     * \n     * @param assets Amount of FXRP to withdraw\n     * @param receiver Address to receive FXRP\n     * @param owner Address whose shXRP will be burned\n     * @return shares Amount of shXRP burned\n     */\n    function withdraw(uint256 assets, address receiver, address owner)\n        public\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        returns (uint256)\n    {\n        return super.withdraw(assets, receiver, owner);\n    }\n    \n    /**\n     * @dev Redeem shXRP shares for FXRP\n     * \n     * Adds reentrancy protection to standard ERC-4626 redeem\n     * \n     * Use Case:\n     * When user wants to burn exact number of shares\n     * \n     * @param shares Amount of shXRP to redeem\n     * @param receiver Address to receive FXRP\n     * @param owner Address whose shXRP will be burned\n     * @return assets Amount of FXRP withdrawn\n     */\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        returns (uint256)\n    {\n        return super.redeem(shares, receiver, owner);\n    }\n    \n    /**\n     * @dev Override ERC4626 _deposit to enforce deposit limit and collect fees\n     * \n     * ERC4626 Compliance (Critical):\n     * The 'shares' parameter is already fee-adjusted from previewDeposit() or previewMint().\n     * This ensures preview functions accurately reflect actual deposit outcomes.\n     * \n     * Flow:\n     * 1. User deposits 'assets' FXRP\n     * 2. previewDeposit() calculated 'shares' accounting for 0.2% fee\n     * 3. super._deposit() transfers assets and mints fee-adjusted shares\n     * 4. Fee is collected from vault balance and sent to RevenueRouter\n     * \n     * Example:\n     * - User deposits 1000 FXRP\n     * - previewDeposit(1000) returns shares worth 998 FXRP (2 FXRP fee deducted)\n     * - super._deposit() mints shares worth 998 FXRP\n     * - 2 FXRP fee transferred to RevenueRouter for buyback & burn\n     * \n     * SECURITY (Firelight Protocol Pattern):\n     * Deposit limit prevents uncontrolled TVL growth during beta/audit phase.\n     * \n     * @param caller Address initiating deposit\n     * @param receiver Address receiving shares\n     * @param assets Amount of FXRP being deposited (gross amount)\n     * @param shares Amount of shares being minted (fee-adjusted, fewer than without fee)\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal override {\n        // Enforce deposit limit BEFORE accepting assets\n        require(totalAssets() + assets <= depositLimit, \"Deposit limit exceeded\");\n        \n        // Standard ERC4626 deposit flow with fee-adjusted shares\n        // The 'shares' parameter is already reduced to account for 0.2% deposit fee\n        // This was calculated in previewDeposit() which deducts fee before share conversion\n        super._deposit(caller, receiver, assets, shares);\n        \n        // Collect 0.2% deposit fee and transfer to RevenueRouter\n        // Fee is taken from vault's balance (already received from caller)\n        IERC20 fxrp = IERC20(asset());\n        uint256 depositFee = (assets * DEPOSIT_FEE_BPS) / 10000;\n        if (depositFee > 0) {\n            fxrp.safeTransfer(revenueRouter, depositFee);\n            emit FeeTransferred(\"deposit\", depositFee, revenueRouter);\n        }\n    }\n    \n    /**\n     * @dev Override ERC4626 _withdraw to implement buffer-aware withdrawals and collect fees\n     * \n     * ERC4626 Compliance (Critical):\n     * The 'shares' parameter is already fee-adjusted from previewWithdraw() or previewRedeem().\n     * This ensures preview functions accurately reflect actual withdrawal outcomes.\n     * \n     * Flow:\n     * 1. Calculate gross assets from fee-adjusted shares\n     * 2. Check if buffer has enough FXRP (user withdrawal + fee)\n     * 3. If insufficient, pull from strategies into buffer\n     * 4. super._withdraw() burns shares and transfers assets to user\n     * 5. Fee is collected from vault balance and sent to RevenueRouter\n     * \n     * Example (withdraw path):\n     * - User calls withdraw(1000 FXRP)\n     * - previewWithdraw(1000) returns shares worth 1002 FXRP (2 FXRP fee included)\n     * - super._withdraw() burns shares worth 1002 FXRP, transfers 1000 to user\n     * - 2 FXRP fee transferred to RevenueRouter for buyback & burn\n     * \n     * Example (redeem path):\n     * - User calls redeem(shares worth 1000 FXRP)\n     * - previewRedeem(shares) returns 998 FXRP (2 FXRP fee deducted)\n     * - super._withdraw() burns shares worth 1000 FXRP, transfers 998 to user\n     * - 2 FXRP fee transferred to RevenueRouter for buyback & burn\n     * \n     * Buffer Replenishment:\n     * If vault buffer insufficient, pulls liquidity from strategies proportionally.\n     * Preserves instant withdrawal UX when buffer has capacity.\n     * \n     * @param caller Address initiating withdrawal\n     * @param receiver Address receiving withdrawn FXRP\n     * @param owner Address whose shares are being burned\n     * @param assets Amount of FXRP to withdraw (what user receives)\n     * @param shares Amount of shares to burn (fee-adjusted, more than just for assets)\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal override {\n        IERC20 fxrp = IERC20(asset());\n        \n        // Calculate gross assets represented by shares (before fee deduction)\n        // This includes both the user's withdrawal and the fee\n        uint256 grossAssets = super.previewRedeem(shares);\n        uint256 withdrawFee = grossAssets - assets;\n        \n        uint256 bufferBalance = fxrp.balanceOf(address(this));\n        \n        // Case 1: Buffer has enough for withdrawal + fee\n        if (bufferBalance >= grossAssets) {\n            // Use standard ERC4626 flow with fee-adjusted shares\n            // The 'shares' parameter is already adjusted to account for 0.2% withdrawal fee\n            // This was calculated in previewWithdraw() or previewRedeem()\n            super._withdraw(caller, receiver, owner, assets, shares);\n            \n            // Collect 0.2% withdrawal fee and transfer to RevenueRouter\n            if (withdrawFee > 0) {\n                fxrp.safeTransfer(revenueRouter, withdrawFee);\n                emit FeeTransferred(\"withdraw\", withdrawFee, revenueRouter);\n            }\n            return;\n        }\n        \n        // Case 2: Buffer insufficient - replenish from strategies FIRST\n        uint256 shortfall = grossAssets - bufferBalance;\n        \n        // Pull liquidity from strategies into buffer (including fee amount)\n        _withdrawFromStrategies(shortfall);\n        \n        // Verify buffer now has enough for withdrawal + fee\n        require(fxrp.balanceOf(address(this)) >= grossAssets, \"Insufficient liquidity in vault and strategies\");\n        \n        // Use standard ERC4626 flow with fee-adjusted shares\n        super._withdraw(caller, receiver, owner, assets, shares);\n        \n        // Collect 0.2% withdrawal fee and transfer to RevenueRouter\n        if (withdrawFee > 0) {\n            fxrp.safeTransfer(revenueRouter, withdrawFee);\n            emit FeeTransferred(\"withdraw\", withdrawFee, revenueRouter);\n        }\n    }\n    \n    /**\n     * @dev Withdraw FXRP from strategies proportionally\n     * \n     * Helper for buffer-aware withdrawals.\n     * Withdraws from active/paused strategies proportionally based on totalDeployed.\n     * \n     * CRITICAL Accounting (Architect Requirements):\n     * - Use balanceBefore/balanceAfter pattern for safe accounting\n     * - Update totalDeployed with actual received amount\n     * - Try/catch pattern: skip failed strategies, continue to next\n     * - Emit WithdrawnFromStrategy event for each successful withdrawal\n     * - ROUNDING FIX: Allocate remainder to last eligible strategy\n     * \n     * Rounding Issue Fix (Architect Review):\n     * Integer division rounds down, leaving unpaid remainder.\n     * Example: shortfall=91, Kinetic=50%, Firelight=50%\n     *   - Kinetic gets: (50*91)/100 = 45 (rounds down from 45.5)\n     *   - Firelight gets: (50*91)/100 = 45 (rounds down from 45.5)\n     *   - Total: 45+45 = 90, missing 1 FXRP!\n     * Solution: Give last strategy the remainder (91-90=1)\n     * \n     * Edge Cases Handled:\n     * - Strategy returns less than requested (accept partial, continue)\n     * - Strategy withdrawal fails (try/catch, skip to next)\n     * - No strategies deployed (return 0)\n     * - Total deployed is zero (return 0)\n     * - Rounding remainder allocated to last strategy\n     * \n     * @param amount Total amount needed from strategies\n     * @return uint256 Actual amount withdrawn from all strategies\n     */\n    function _withdrawFromStrategies(uint256 amount) internal returns (uint256) {\n        // Calculate total deployed across active/paused strategies\n        uint256 totalDeployed = 0;\n        address[] memory eligibleStrategies = new address[](strategyList.length);\n        uint256 eligibleCount = 0;\n        \n        for (uint256 i = 0; i < strategyList.length; i++) {\n            address strategy = strategyList[i];\n            StrategyInfo storage info = strategies[strategy];\n            \n            // Include both Active and Paused strategies\n            if ((info.status == StrategyStatus.Active || info.status == StrategyStatus.Paused) && \n                info.totalDeployed > 0) {\n                totalDeployed += info.totalDeployed;\n                eligibleStrategies[eligibleCount] = strategy;\n                eligibleCount++;\n            }\n        }\n        \n        // Edge case: no strategies deployed\n        if (totalDeployed == 0 || eligibleCount == 0) {\n            return 0;\n        }\n        \n        uint256 totalWithdrawn = 0;\n        uint256 remainingToWithdraw = amount;\n        IERC20 fxrp = IERC20(asset());\n        \n        // Withdraw proportionally from each eligible strategy\n        for (uint256 i = 0; i < eligibleCount; i++) {\n            address strategy = eligibleStrategies[i];\n            StrategyInfo storage info = strategies[strategy];\n            \n            // Calculate this strategy's proportional share\n            uint256 strategyAmount;\n            \n            // ROUNDING FIX: Last strategy gets remainder\n            if (i == eligibleCount - 1) {\n                // Last strategy: give it all remaining amount\n                strategyAmount = remainingToWithdraw;\n            } else {\n                // Other strategies: proportional share (rounds down)\n                strategyAmount = (info.totalDeployed * amount) / totalDeployed;\n            }\n            \n            // EDGE CASE FIX: Cap request at strategy's totalDeployed\n            // Prevents asking strategy for more than it has\n            if (strategyAmount > info.totalDeployed) {\n                strategyAmount = info.totalDeployed;\n            }\n            \n            if (strategyAmount == 0 || remainingToWithdraw == 0) {\n                continue;\n            }\n            \n            // Request withdrawal from strategy (with safe accounting)\n            uint256 balanceBefore = fxrp.balanceOf(address(this));\n            \n            try IStrategy(strategy).withdraw(strategyAmount, address(this)) returns (uint256 actualAmount) {\n                uint256 balanceAfter = fxrp.balanceOf(address(this));\n                \n                // Verify funds actually received\n                if (balanceAfter > balanceBefore) {\n                    uint256 received = balanceAfter - balanceBefore;\n                    \n                    // Update tracking with safe accounting\n                    if (info.totalDeployed >= received) {\n                        info.totalDeployed -= received;\n                    } else {\n                        info.totalDeployed = 0;\n                    }\n                    \n                    totalWithdrawn += received;\n                    \n                    // UNDERFLOW FIX: Cap decrement at remainingToWithdraw\n                    // Prevents underflow if strategy returns more than requested (yield, rebates)\n                    uint256 toDecrement = received < remainingToWithdraw ? received : remainingToWithdraw;\n                    remainingToWithdraw -= toDecrement;\n                    \n                    // Emit event for transparency\n                    emit WithdrawnFromStrategy(strategy, strategyAmount, actualAmount);\n                }\n            } catch {\n                // Strategy withdrawal failed - skip to next strategy\n                // This allows partial success rather than complete revert\n                continue;\n            }\n        }\n        \n        return totalWithdrawn;\n    }\n    \n    // ========================================\n    // OPERATOR MANAGEMENT\n    // ========================================\n    \n    /**\n     * @dev Add an operator who can manage Firelight deposits\n     * \n     * Operators coordinate:\n     * - Deploying idle FXRP to Firelight for yield\n     * - Withdrawing from Firelight when users redeem\n     * - Rebalancing between vault and Firelight\n     * \n     * @param operator Address of the operator\n     */\n    function addOperator(address operator) external onlyOwner {\n        require(operator != address(0), \"Invalid operator address\");\n        operators[operator] = true;\n        emit OperatorAdded(operator);\n    }\n    \n    /**\n     * @dev Remove an operator\n     * @param operator Address of the operator\n     */\n    function removeOperator(address operator) external onlyOwner {\n        operators[operator] = false;\n        emit OperatorRemoved(operator);\n    }\n    \n    // ========================================\n    // ADMIN FUNCTIONS\n    // ========================================\n    \n    /**\n     * @dev Update minimum deposit amount\n     * @param newMinDeposit New minimum deposit (FXRP has 6 decimals)\n     * \n     * Example: 0.01 FXRP = 10000 (0.01 * 10^6)\n     */\n    function setMinDeposit(uint256 newMinDeposit) external onlyOwner {\n        require(newMinDeposit > 0, \"Min deposit must be positive\");\n        minDeposit = newMinDeposit;\n        emit MinDepositUpdated(newMinDeposit);\n    }\n    \n    /**\n     * @dev Update maximum deposit limit\n     * \n     * Security Feature (Firelight Protocol Pattern):\n     * Controls total TVL to manage risk and match strategy capacity.\n     * \n     * Recommended Progression:\n     * 1. Beta Launch: 100K FXRP (~$210K at $2.10/XRP)\n     * 2. Post-Audit: 1M FXRP (~$2.1M)\n     * 3. Growth Phase: 10M FXRP (~$21M)\n     * 4. Mature: Uncapped (type(uint256).max) if strategies support unlimited TVL\n     * \n     * @param newDepositLimit New deposit limit in FXRP (6 decimals)\n     * \n     * Example: 1M FXRP = 1_000_000e6 = 1000000000000\n     */\n    function setDepositLimit(uint256 newDepositLimit) external onlyOwner {\n        require(newDepositLimit > 0, \"Deposit limit must be positive\");\n        depositLimit = newDepositLimit;\n        emit DepositLimitUpdated(newDepositLimit);\n    }\n    \n    /**\n     * @dev Pause all deposits and withdrawals\n     * \n     * Emergency Stop (Firelight Protocol Pattern):\n     * Immediately halts all vault operations to contain exploits or vulnerabilities.\n     * \n     * Use Cases:\n     * - Critical bug discovered in vault or strategy\n     * - Ongoing exploit/attack detected\n     * - Suspicious activity requiring investigation\n     * - Major protocol upgrade requiring migration\n     * \n     * Effects When Paused:\n     * - ❌ deposit() reverts\n     * - ❌ mint() reverts\n     * - ❌ withdraw() reverts\n     * - ❌ redeem() reverts\n     * - ✅ View functions still work (totalAssets, balanceOf, etc.)\n     * - ✅ Owner can still manage strategies (emergency withdrawals)\n     * \n     * Recovery:\n     * Call unpause() after issue is resolved.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n    \n    /**\n     * @dev Unpause deposits and withdrawals\n     * \n     * Restores normal vault operations after emergency pause.\n     * \n     * Requirements:\n     * - Only owner can unpause\n     * - Vault must currently be paused\n     * - Issue that caused pause must be resolved\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n    \n    // ========================================\n    // STRATEGY MANAGEMENT\n    // ========================================\n    \n    /**\n     * @dev Add a new yield strategy to the vault\n     * \n     * CRITICAL FIX (Architect Review):\n     * Validates aggregate target allocations to prevent over-allocation\n     * \n     * Validation:\n     * - Strategy address must be valid contract\n     * - Strategy must implement IStrategy interface\n     * - Strategy asset must match vault asset (FXRP)\n     * - Strategy cannot already exist\n     * - Total allocations (buffer + all strategies) cannot exceed 100%\n     * \n     * Example:\n     * - Buffer target: 10% (1000 bps)\n     * - Kinetic target: 40% (4000 bps)\n     * - Firelight target: 50% (5000 bps)\n     * - Total: 100% (10000 bps) ✓\n     * \n     * @param strategy Address of IStrategy contract\n     * @param targetBps Target allocation in basis points (10000 = 100%)\n     */\n    function addStrategy(address strategy, uint256 targetBps) external onlyOwner {\n        require(strategy != address(0), \"Invalid strategy address\");\n        require(strategies[strategy].strategyAddress == address(0), \"Strategy already exists\");\n        require(targetBps <= 10000, \"Target cannot exceed 100%\");\n        \n        // CRITICAL: Validate aggregate allocation doesn't exceed 100%\n        uint256 newTotalTargets = totalStrategyTargetBps + targetBps + bufferTargetBps;\n        require(newTotalTargets <= 10000, \"Total targets exceed 100%\");\n        \n        // Verify strategy implements IStrategy and uses correct asset\n        try IStrategy(strategy).asset() returns (address strategyAsset) {\n            require(strategyAsset == address(asset()), \"Strategy asset mismatch\");\n        } catch {\n            revert(\"Invalid strategy contract\");\n        }\n        \n        // Add to mapping and list\n        strategies[strategy] = StrategyInfo({\n            strategyAddress: strategy,\n            targetBps: targetBps,\n            status: StrategyStatus.Inactive,  // Start inactive, activate manually\n            totalDeployed: 0,\n            lastReportTimestamp: block.timestamp\n        });\n        strategyList.push(strategy);\n        \n        // Update aggregate tracking\n        totalStrategyTargetBps += targetBps;\n        \n        emit StrategyAdded(strategy, targetBps);\n    }\n    \n    /**\n     * @dev Remove a strategy from the vault\n     * \n     * Requirements:\n     * - All funds must be withdrawn from strategy first\n     * - Strategy must exist\n     * - Safer to deprecate first, then remove after cooldown\n     * \n     * Updates aggregate target tracking when removing strategy.\n     * \n     * @param strategy Address of strategy to remove\n     */\n    function removeStrategy(address strategy) external onlyOwner {\n        require(strategies[strategy].strategyAddress != address(0), \"Strategy does not exist\");\n        require(strategies[strategy].totalDeployed == 0, \"Strategy still has funds\");\n        \n        // Update aggregate tracking before removal\n        totalStrategyTargetBps -= strategies[strategy].targetBps;\n        \n        // Remove from mapping\n        delete strategies[strategy];\n        \n        // Remove from list (swap with last, then pop)\n        for (uint256 i = 0; i < strategyList.length; i++) {\n            if (strategyList[i] == strategy) {\n                strategyList[i] = strategyList[strategyList.length - 1];\n                strategyList.pop();\n                break;\n            }\n        }\n        \n        emit StrategyRemoved(strategy);\n    }\n    \n    /**\n     * @dev Update target allocation for a strategy\n     * \n     * CRITICAL FIX (Architect Review):\n     * Validates aggregate targets don't exceed 100% after update\n     * \n     * Note: This only updates the target. Actual rebalancing\n     * must be triggered separately via deployToStrategy/withdrawFromStrategy.\n     * \n     * @param strategy Address of strategy\n     * @param newTargetBps New target allocation in basis points\n     */\n    function updateAllocation(address strategy, uint256 newTargetBps) external onlyOwner {\n        require(strategies[strategy].strategyAddress != address(0), \"Strategy does not exist\");\n        require(newTargetBps <= 10000, \"Target cannot exceed 100%\");\n        \n        // Calculate new aggregate (remove old target, add new target)\n        uint256 oldTargetBps = strategies[strategy].targetBps;\n        uint256 newTotalTargets = totalStrategyTargetBps - oldTargetBps + newTargetBps + bufferTargetBps;\n        require(newTotalTargets <= 10000, \"Total targets exceed 100%\");\n        \n        // Update tracking\n        totalStrategyTargetBps = totalStrategyTargetBps - oldTargetBps + newTargetBps;\n        strategies[strategy].targetBps = newTargetBps;\n        \n        emit StrategyAllocationUpdated(strategy, newTargetBps);\n    }\n    \n    /**\n     * @dev Deploy FXRP from vault buffer to a strategy\n     * \n     * CRITICAL FIX (Architect Review):\n     * Uses approval pattern to prevent double-counting in totalAssets()\n     * \n     * Flow:\n     * 1. Check vault has sufficient buffer\n     * 2. Approve strategy to pull FXRP from vault\n     * 3. Call strategy.deploy(amount) - strategy pulls via transferFrom\n     * 4. Verify vault balance actually decreased (strategy pulled funds)\n     * 5. Update totalDeployed tracking\n     * \n     * Why this fixes double-counting:\n     * - Vault balance decreases atomically when strategy calls transferFrom\n     * - No intermediate state where FXRP sits on strategy contract\n     * - totalAssets() = vault balance (reduced) + strategy.totalAssets() (external holdings) ✓\n     * \n     * @param strategy Address of strategy to deploy to\n     * @param amount Amount of FXRP to deploy\n     */\n    function deployToStrategy(address strategy, uint256 amount) external onlyOperator nonReentrant {\n        require(strategies[strategy].strategyAddress != address(0), \"Strategy does not exist\");\n        require(strategies[strategy].status == StrategyStatus.Active, \"Strategy not active\");\n        require(amount > 0, \"Amount must be positive\");\n        \n        IERC20 fxrp = IERC20(asset());\n        uint256 vaultBalanceBefore = fxrp.balanceOf(address(this));\n        require(vaultBalanceBefore >= amount, \"Insufficient vault balance\");\n        \n        // Approve strategy to pull FXRP from vault\n        fxrp.approve(strategy, amount);\n        \n        // Strategy pulls FXRP and deploys to external protocol\n        // This ensures vault balance decreases atomically\n        IStrategy(strategy).deploy(amount);\n        \n        // Verify funds actually left vault (strategy must have pulled them)\n        uint256 vaultBalanceAfter = fxrp.balanceOf(address(this));\n        uint256 actualDeployed = vaultBalanceBefore - vaultBalanceAfter;\n        require(actualDeployed > 0, \"Strategy did not pull funds\");\n        require(actualDeployed <= amount, \"Strategy pulled more than approved\");\n        \n        // Update tracking with actual deployed amount\n        strategies[strategy].totalDeployed += actualDeployed;\n        \n        // Clear any leftover approval\n        if (fxrp.allowance(address(this), strategy) > 0) {\n            fxrp.approve(strategy, 0);\n        }\n        \n        emit DeployedToStrategy(strategy, actualDeployed);\n    }\n    \n    /**\n     * @dev Withdraw FXRP from a strategy back to vault buffer\n     * \n     * CRITICAL FIX (Architect Review):\n     * Safely handles partial withdrawals and accounting edge cases\n     * \n     * Flow:\n     * 1. Record vault balance before withdrawal\n     * 2. Call strategy.withdraw(amount, address(this))\n     * 3. Verify vault balance increased (funds received)\n     * 4. Update totalDeployed tracking with actual received amount\n     * \n     * Edge Cases Handled:\n     * - Strategy returns less than requested (partial withdrawal)\n     * - Strategy has withdrawal fees (received < requested)\n     * - totalDeployed underflow protection\n     * \n     * @param strategy Address of strategy to withdraw from\n     * @param amount Amount of FXRP to withdraw\n     */\n    function withdrawFromStrategy(address strategy, uint256 amount) external onlyOperator nonReentrant {\n        require(strategies[strategy].strategyAddress != address(0), \"Strategy does not exist\");\n        require(amount > 0, \"Amount must be positive\");\n        require(amount <= strategies[strategy].totalDeployed, \"Withdraw exceeds deployed\");\n        \n        uint256 balanceBefore = IERC20(asset()).balanceOf(address(this));\n        \n        // Request withdrawal from strategy\n        uint256 actualAmount = IStrategy(strategy).withdraw(amount, address(this));\n        \n        uint256 balanceAfter = IERC20(asset()).balanceOf(address(this));\n        \n        // Verify funds were received (prevents underflow)\n        require(balanceAfter >= balanceBefore, \"Vault balance decreased\");\n        uint256 received = balanceAfter - balanceBefore;\n        require(received > 0, \"No funds received from strategy\");\n        \n        // Update tracking with actual received amount (safe from underflow)\n        if (strategies[strategy].totalDeployed >= received) {\n            strategies[strategy].totalDeployed -= received;\n        } else {\n            // Edge case: received more than tracked (profit from yield)\n            strategies[strategy].totalDeployed = 0;\n        }\n        \n        emit WithdrawnFromStrategy(strategy, amount, actualAmount);\n    }\n    \n    /**\n     * @dev Pause a strategy (emergency stop)\n     * \n     * Paused strategies:\n     * - Stop receiving new deployments\n     * - Still counted in totalAssets()\n     * - Can be resumed by owner\n     * \n     * @param strategy Address of strategy to pause\n     */\n    function pauseStrategy(address strategy) external onlyOperator {\n        require(strategies[strategy].strategyAddress != address(0), \"Strategy does not exist\");\n        require(strategies[strategy].status == StrategyStatus.Active, \"Strategy not active\");\n        \n        strategies[strategy].status = StrategyStatus.Paused;\n        emit StrategyStatusUpdated(strategy, StrategyStatus.Paused);\n    }\n    \n    /**\n     * @dev Resume a paused strategy\n     * \n     * @param strategy Address of strategy to resume\n     */\n    function resumeStrategy(address strategy) external onlyOwner {\n        require(strategies[strategy].strategyAddress != address(0), \"Strategy does not exist\");\n        require(strategies[strategy].status == StrategyStatus.Paused, \"Strategy not paused\");\n        \n        strategies[strategy].status = StrategyStatus.Active;\n        emit StrategyStatusUpdated(strategy, StrategyStatus.Active);\n    }\n    \n    /**\n     * @dev Activate an inactive strategy\n     * \n     * New strategies start as Inactive and must be explicitly activated.\n     * \n     * @param strategy Address of strategy to activate\n     */\n    function activateStrategy(address strategy) external onlyOwner {\n        require(strategies[strategy].strategyAddress != address(0), \"Strategy does not exist\");\n        require(strategies[strategy].status == StrategyStatus.Inactive, \"Strategy not inactive\");\n        \n        strategies[strategy].status = StrategyStatus.Active;\n        emit StrategyStatusUpdated(strategy, StrategyStatus.Active);\n    }\n    \n    /**\n     * @dev Report strategy performance and harvest profits\n     * \n     * ERC4626 Compliance (Critical):\n     * This function ensures accurate accounting by properly handling yield fees.\n     * \n     * Strategy Profit Flow:\n     * 1. Strategies REINVEST profits (not transferred to vault buffer)\n     * 2. strategy.report() returns profit/loss amounts, but assets stay in strategy\n     * 3. Vault must PULL fee from strategy to collect it\n     * \n     * Yield Fee Application:\n     * - Deducts 0.1% (adjustable) yield routing fee from profits\n     * - Fee PULLED from strategy to vault, then transferred to RevenueRouter\n     * - Net profit remains in strategy, increasing share value\n     * \n     * Accounting Flow:\n     * 1. Strategy reports: profit=10, loss=0, assetsAfter=110 (reinvested)\n     * 2. Calculate yieldFee = 10 * 0.001 = 0.01\n     * 3. Pull 0.01 from strategy to vault\n     * 4. Transfer 0.01 from vault to revenueRouter\n     * 5. Update totalDeployed = 110 - 0.01 = 109.99\n     * \n     * This ensures totalAssets() accurately reflects vault holdings:\n     * - Buffer + strategy.totalAssets() = buffer + 109.99 (correct)\n     * - Fee sent to revenueRouter (not counted in totalAssets)\n     * - No double-counting, no under-collateralization\n     * \n     * Can be called by anyone (useful for keepers/bots).\n     * \n     * @param strategy Address of strategy to report\n     */\n    function reportStrategy(address strategy) external {\n        require(strategies[strategy].strategyAddress != address(0), \"Strategy does not exist\");\n        require(strategies[strategy].status == StrategyStatus.Active, \"Strategy not active\");\n        \n        // Trigger strategy report (returns profit, loss, totalAssets)\n        // Note: Profit is REINVESTED in strategy, not transferred to vault\n        (uint256 profit, uint256 loss, uint256 assetsAfter) = IStrategy(strategy).report();\n        \n        IERC20 fxrp = IERC20(asset());\n        \n        // Apply yield routing fee to profits (if any)\n        if (profit > 0 && yieldRoutingFeeBps > 0) {\n            // Calculate 0.1% yield fee (or current yieldRoutingFeeBps setting)\n            uint256 yieldFee = (profit * yieldRoutingFeeBps) / 10000;\n            \n            // CRITICAL FIX (ERC4626 Compliance):\n            // Profit is reinvested in strategy, so we must PULL the fee first\n            // This prevents accounting mismatch where vault tries to pay fee from buffer\n            // that doesn't actually have the profit yet\n            uint256 actualWithdrawn = IStrategy(strategy).withdraw(yieldFee, address(this));\n            \n            // Transfer fee to RevenueRouter for SHIELD buyback & burn\n            fxrp.safeTransfer(revenueRouter, actualWithdrawn);\n            emit FeeTransferred(\"yield\", actualWithdrawn, revenueRouter);\n            \n            // Update strategy tracking: assetsAfter - actualWithdrawn\n            // (assetsAfter was before fee withdrawal, so we deduct what we pulled)\n            strategies[strategy].totalDeployed = assetsAfter - actualWithdrawn;\n        } else {\n            // No fee taken, update totalDeployed to match strategy's reported assets\n            strategies[strategy].totalDeployed = assetsAfter;\n        }\n        \n        // Update timestamp\n        strategies[strategy].lastReportTimestamp = block.timestamp;\n        \n        // Emit event with gross profit/loss and final strategy assets\n        emit StrategyReported(strategy, profit, loss, strategies[strategy].totalDeployed);\n    }\n    \n    /**\n     * @dev Update buffer target allocation\n     * \n     * CRITICAL FIX (Architect Review):\n     * Validates aggregate targets don't exceed 100% after buffer update\n     * \n     * Buffer is FXRP held in vault for instant withdrawals.\n     * Default: 1000 bps = 10%\n     * \n     * @param newTargetBps New buffer target in basis points\n     */\n    function setBufferTarget(uint256 newTargetBps) external onlyOwner {\n        require(newTargetBps <= 10000, \"Target cannot exceed 100%\");\n        \n        // Validate aggregate allocation with new buffer target\n        uint256 newTotalTargets = totalStrategyTargetBps + newTargetBps;\n        require(newTotalTargets <= 10000, \"Total targets exceed 100%\");\n        \n        bufferTargetBps = newTargetBps;\n        emit BufferTargetUpdated(newTargetBps);\n    }\n    \n    /**\n     * @dev Update yield routing fee (0-100 bps, max 1%)\n     * \n     * Yield Routing Fee:\n     * - Deducted from strategy profits when reportStrategy() is called\n     * - Sent to RevenueRouter for SHIELD buyback & burn\n     * - Does not affect deposits or withdrawals, only yield generation\n     * \n     * Conservative Range:\n     * - Min: 0 bps (0% - no yield fee)\n     * - Max: 100 bps (1% - reasonable cap to remain competitive)\n     * - Default: 10 bps (0.1% - minimal impact on APY)\n     * \n     * @param newFeeBps New yield routing fee in basis points (0-100)\n     */\n    function setYieldRoutingFeeBps(uint256 newFeeBps) external onlyOwner {\n        require(newFeeBps <= 100, \"Yield fee cannot exceed 1%\");\n        \n        yieldRoutingFeeBps = newFeeBps;\n        emit YieldRoutingFeeUpdated(newFeeBps);\n    }\n    \n    // ========================================\n    // ERC4626 PREVIEW FUNCTIONS (FEE-ADJUSTED)\n    // ========================================\n    \n    /**\n     * @dev Preview how many shares will be minted for asset deposit\n     * \n     * ERC4626 Compliance (Critical):\n     * This MUST reflect the actual shares received after accounting for fees.\n     * \n     * Fee Logic:\n     * 1. Deduct 0.2% deposit fee from assets\n     * 2. Convert net assets to shares using standard ERC4626 math\n     * \n     * Example:\n     * - User deposits 1000 FXRP\n     * - Fee: 1000 * 0.002 = 2 FXRP (sent to RevenueRouter)\n     * - Net: 998 FXRP (converted to shares)\n     * - User receives shares worth 998 FXRP, not 1000 FXRP\n     * \n     * @param assets Amount of FXRP to deposit (gross amount)\n     * @return shares Amount of shXRP that will be minted (fee-adjusted)\n     */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        uint256 fee = (assets * DEPOSIT_FEE_BPS) / 10000;\n        uint256 netAssets = assets - fee;\n        return super.previewDeposit(netAssets);\n    }\n    \n    /**\n     * @dev Preview how many assets are needed to mint exact shares\n     * \n     * ERC4626 Compliance (Critical):\n     * This MUST reflect the actual assets needed after accounting for fees.\n     * \n     * Fee Logic:\n     * 1. Calculate net assets needed for shares (using standard ERC4626 math)\n     * 2. Gross up to account for 0.2% deposit fee\n     * \n     * Math:\n     * - grossAssets * (1 - 0.002) = netAssets\n     * - grossAssets = netAssets / 0.998\n     * - grossAssets = netAssets * 10000 / 9980\n     * \n     * Example:\n     * - User wants shares worth 998 FXRP\n     * - Net assets needed: 998 FXRP\n     * - Gross assets: 998 * 10000 / 9980 = 1000 FXRP\n     * - User deposits 1000 FXRP, fee is 2 FXRP, net is 998 FXRP\n     * \n     * @param shares Amount of shXRP to mint\n     * @return assets Amount of FXRP needed (fee-adjusted)\n     */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        uint256 netAssets = super.previewMint(shares);\n        return (netAssets * 10000) / (10000 - DEPOSIT_FEE_BPS);\n    }\n    \n    /**\n     * @dev Preview how many shares will be burned for asset withdrawal\n     * \n     * ERC4626 Compliance (Critical):\n     * This MUST reflect the actual shares burned after accounting for fees.\n     * \n     * Fee Logic:\n     * 1. User wants 'assets' FXRP\n     * 2. Vault needs to provide assets + 0.2% fee\n     * 3. Convert total assets to shares using standard ERC4626 math\n     * \n     * Example:\n     * - User wants 1000 FXRP\n     * - Fee: 1000 * 0.002 = 2 FXRP (sent to RevenueRouter)\n     * - Total needed: 1002 FXRP\n     * - Burn shares worth 1002 FXRP\n     * - User receives 1000 FXRP, fee is 2 FXRP\n     * \n     * @param assets Amount of FXRP to withdraw\n     * @return shares Amount of shXRP that will be burned (fee-adjusted)\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        uint256 fee = (assets * WITHDRAW_FEE_BPS) / 10000;\n        uint256 totalAssetsNeeded = assets + fee;\n        return super.previewWithdraw(totalAssetsNeeded);\n    }\n    \n    /**\n     * @dev Preview how many assets will be received for share redemption\n     * \n     * ERC4626 Compliance (Critical):\n     * This MUST reflect the actual assets received after accounting for fees.\n     * \n     * Fee Logic:\n     * 1. Convert shares to gross assets using standard ERC4626 math\n     * 2. Deduct 0.2% withdrawal fee\n     * 3. User receives net assets\n     * \n     * Example:\n     * - User redeems shares worth 1000 FXRP\n     * - Gross assets: 1000 FXRP\n     * - Fee: 1000 * 0.002 = 2 FXRP (sent to RevenueRouter)\n     * - Net: 998 FXRP (transferred to user)\n     * \n     * @param shares Amount of shXRP to redeem\n     * @return assets Amount of FXRP that will be received (fee-adjusted)\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        uint256 grossAssets = super.previewRedeem(shares);\n        uint256 fee = (grossAssets * WITHDRAW_FEE_BPS) / 10000;\n        return grossAssets - fee;\n    }\n    \n    // ========================================\n    // BUFFER & STRATEGY VIEW FUNCTIONS\n    // ========================================\n    \n    /**\n     * @dev Get current FXRP balance held in vault buffer\n     * \n     * Buffer is used for:\n     * - Instant withdrawals (no strategy unwinding delay)\n     * - Gas for rebalancing operations\n     * - Safety cushion for strategy failures\n     * \n     * @return Current FXRP balance in vault\n     */\n    function getBufferBalance() public view returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n    \n    /**\n     * @dev Calculate target buffer size based on totalAssets\n     * \n     * Formula: targetBuffer = totalAssets() * bufferTargetBps / 10000\n     * Example: If totalAssets = 1M FXRP and bufferTargetBps = 1000 (10%)\n     *          then targetBuffer = 100K FXRP\n     * \n     * @return Target buffer amount in FXRP\n     */\n    function getBufferTarget() public view returns (uint256) {\n        return (totalAssets() * bufferTargetBps) / 10000;\n    }\n    \n    /**\n     * @dev Get comprehensive buffer status for monitoring\n     * \n     * Returns:\n     * - current: Current FXRP in buffer\n     * - target: Target FXRP buffer based on allocation\n     * - deficit: Amount below target (0 if above target)\n     * - surplus: Amount above target (0 if below target)\n     * - targetBps: Target buffer as % of totalAssets\n     * \n     * @return current Current buffer balance\n     * @return target Target buffer balance\n     * @return deficit Amount below target\n     * @return surplus Amount above target\n     * @return targetBps Buffer target in basis points\n     */\n    function getBufferStatus() \n        public \n        view \n        returns (\n            uint256 current,\n            uint256 target,\n            uint256 deficit,\n            uint256 surplus,\n            uint256 targetBps\n        ) \n    {\n        current = getBufferBalance();\n        target = getBufferTarget();\n        targetBps = bufferTargetBps;\n        \n        if (current < target) {\n            deficit = target - current;\n            surplus = 0;\n        } else {\n            deficit = 0;\n            surplus = current - target;\n        }\n    }\n    \n    /**\n     * @dev Get total FXRP deployed across all strategies\n     * \n     * @return Total FXRP deployed to strategies\n     */\n    function getTotalDeployed() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < strategyList.length; i++) {\n            total += strategies[strategyList[i]].totalDeployed;\n        }\n        return total;\n    }\n    \n    /**\n     * @dev Get detailed info for a specific strategy\n     * \n     * @param strategy Address of strategy\n     * @return info StrategyInfo struct with all details\n     */\n    function getStrategyInfo(address strategy) public view returns (StrategyInfo memory info) {\n        require(strategies[strategy].strategyAddress != address(0), \"Strategy does not exist\");\n        return strategies[strategy];\n    }\n    \n    /**\n     * @dev Get list of all strategy addresses\n     * \n     * @return Array of strategy addresses\n     */\n    function getAllStrategies() public view returns (address[] memory) {\n        return strategyList;\n    }\n    \n    /**\n     * @dev Get list of only active strategy addresses\n     * \n     * @return Array of active strategy addresses\n     */\n    function getActiveStrategies() public view returns (address[] memory) {\n        // First count active strategies\n        uint256 activeCount = 0;\n        for (uint256 i = 0; i < strategyList.length; i++) {\n            if (strategies[strategyList[i]].status == StrategyStatus.Active) {\n                activeCount++;\n            }\n        }\n        \n        // Create array of active strategies\n        address[] memory activeList = new address[](activeCount);\n        uint256 index = 0;\n        for (uint256 i = 0; i < strategyList.length; i++) {\n            if (strategies[strategyList[i]].status == StrategyStatus.Active) {\n                activeList[index] = strategyList[i];\n                index++;\n            }\n        }\n        \n        return activeList;\n    }\n    \n    /**\n     * @dev Get current allocation percentages for monitoring\n     * \n     * Returns arrays of:\n     * - strategies: Strategy addresses\n     * - allocations: Current allocation in basis points (calculated from totalAssets)\n     * - targets: Target allocation in basis points (from StrategyInfo)\n     * \n     * @return strategies_ Array of strategy addresses\n     * @return allocations Array of current allocations (bps)\n     * @return targets Array of target allocations (bps)\n     */\n    function getCurrentAllocations() \n        public \n        view \n        returns (\n            address[] memory strategies_,\n            uint256[] memory allocations,\n            uint256[] memory targets\n        ) \n    {\n        uint256 totalAssets_ = totalAssets();\n        uint256 length = strategyList.length;\n        \n        strategies_ = new address[](length + 1); // +1 for buffer\n        allocations = new uint256[](length + 1);\n        targets = new uint256[](length + 1);\n        \n        // Buffer entry (index 0)\n        strategies_[0] = address(0); // Use address(0) to represent buffer\n        if (totalAssets_ > 0) {\n            allocations[0] = (getBufferBalance() * 10000) / totalAssets_;\n        }\n        targets[0] = bufferTargetBps;\n        \n        // Strategy entries\n        for (uint256 i = 0; i < length; i++) {\n            address strategy = strategyList[i];\n            strategies_[i + 1] = strategy;\n            \n            // Calculate current allocation\n            if (totalAssets_ > 0 && strategies[strategy].status == StrategyStatus.Active) {\n                try IStrategy(strategy).totalAssets() returns (uint256 strategyAssets) {\n                    allocations[i + 1] = (strategyAssets * 10000) / totalAssets_;\n                } catch {\n                    allocations[i + 1] = (strategies[strategy].totalDeployed * 10000) / totalAssets_;\n                }\n            }\n            \n            targets[i + 1] = strategies[strategy].targetBps;\n        }\n    }\n}\n"
      },
      "project/contracts/VaultController.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ShXRPVault.sol\";\nimport \"./interfaces/IStrategy.sol\";\n\n/**\n * @title VaultController\n * @dev Manages operator permissions, compounding, and multi-strategy coordination for ShXRP vaults\n */\ncontract VaultController is AccessControl, ReentrancyGuard {\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    bytes32 public constant COMPOUNDER_ROLE = keccak256(\"COMPOUNDER_ROLE\");\n    \n    // Registered vaults\n    mapping(address => bool) public registeredVaults;\n    address[] public vaultList;\n    \n    // Strategy registry\n    mapping(address => bool) public registeredStrategies;\n    address[] public strategyList;\n    mapping(address => string) public strategyNames;\n    \n    // Target allocations (basis points, 10000 = 100%)\n    uint256 public constant BUFFER_TARGET_BPS = 1000;  // 10%\n    uint256 public constant KINETIC_TARGET_BPS = 4000; // 40%\n    uint256 public constant FIRELIGHT_TARGET_BPS = 5000; // 50%\n    \n    // Compounding configuration\n    uint256 public minCompoundInterval = 1 hours;\n    mapping(address => uint256) public lastCompoundTime;\n    \n    // Bridging tracking\n    mapping(bytes32 => BridgeRequest) public bridgeRequests;\n    \n    struct BridgeRequest {\n        address user;\n        address vault;\n        uint256 xrpAmount;\n        uint256 fxrpExpected;\n        uint256 timestamp;\n        BridgeStatus status;\n        string xrplTxHash;\n        string flareTxHash;\n    }\n    \n    enum BridgeStatus {\n        Pending,\n        XRPLConfirmed,\n        BridgingInProgress,\n        FXRPReceived,\n        VaultMinted,\n        Failed,\n        Cancelled\n    }\n    \n    // Events\n    event VaultRegistered(address indexed vault);\n    event VaultDeregistered(address indexed vault);\n    event BridgeRequestCreated(bytes32 indexed requestId, address indexed user, uint256 xrpAmount);\n    event BridgeStatusUpdated(bytes32 indexed requestId, BridgeStatus newStatus);\n    event CompoundExecuted(address indexed vault, uint256 yieldAmount);\n    event OperatorAdded(address indexed operator);\n    event OperatorRemoved(address indexed operator);\n    \n    // Strategy Events\n    event StrategyRegistered(address indexed strategy, string name);\n    event StrategyDeregistered(address indexed strategy);\n    event StrategyDeployed(address indexed vault, address indexed strategy, uint256 amount);\n    event StrategyWithdrawn(address indexed vault, address indexed strategy, uint256 amount);\n    event VaultRebalanced(\n        address indexed vault,\n        uint256 bufferBefore,\n        uint256 bufferAfter,\n        uint256 kineticBefore,\n        uint256 kineticAfter,\n        uint256 firelightBefore,\n        uint256 firelightAfter\n    );\n    \n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(OPERATOR_ROLE, msg.sender);\n        _grantRole(COMPOUNDER_ROLE, msg.sender);\n    }\n    \n    // Vault management\n    function registerVault(address vault) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(!registeredVaults[vault], \"Vault already registered\");\n        registeredVaults[vault] = true;\n        vaultList.push(vault);\n        emit VaultRegistered(vault);\n    }\n    \n    function deregisterVault(address vault) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(registeredVaults[vault], \"Vault not registered\");\n        registeredVaults[vault] = false;\n        emit VaultDeregistered(vault);\n    }\n    \n    // Bridge request management\n    function createBridgeRequest(\n        address user,\n        address vault,\n        uint256 xrpAmount,\n        string calldata xrplTxHash\n    ) external onlyRole(OPERATOR_ROLE) returns (bytes32) {\n        bytes32 requestId = keccak256(abi.encodePacked(user, vault, xrpAmount, block.timestamp));\n        \n        bridgeRequests[requestId] = BridgeRequest({\n            user: user,\n            vault: vault,\n            xrpAmount: xrpAmount,\n            fxrpExpected: xrpAmount, // 1:1 initially, can add conversion logic\n            timestamp: block.timestamp,\n            status: BridgeStatus.Pending,\n            xrplTxHash: xrplTxHash,\n            flareTxHash: \"\"\n        });\n        \n        emit BridgeRequestCreated(requestId, user, xrpAmount);\n        return requestId;\n    }\n    \n    function updateBridgeStatus(\n        bytes32 requestId,\n        BridgeStatus newStatus,\n        string calldata flareTxHash\n    ) external onlyRole(OPERATOR_ROLE) {\n        BridgeRequest storage request = bridgeRequests[requestId];\n        require(request.timestamp > 0, \"Request not found\");\n        \n        request.status = newStatus;\n        if (bytes(flareTxHash).length > 0) {\n            request.flareTxHash = flareTxHash;\n        }\n        \n        emit BridgeStatusUpdated(requestId, newStatus);\n    }\n    \n    // Compounding\n    function executeCompound(address vault) \n        external \n        onlyRole(COMPOUNDER_ROLE) \n        nonReentrant \n    {\n        require(registeredVaults[vault], \"Vault not registered\");\n        require(\n            block.timestamp >= lastCompoundTime[vault] + minCompoundInterval,\n            \"Compound interval not reached\"\n        );\n        \n        // Call vault's compound function (to be implemented)\n        // For now, just update timestamp\n        lastCompoundTime[vault] = block.timestamp;\n        \n        emit CompoundExecuted(vault, 0);\n    }\n    \n    function setMinCompoundInterval(uint256 interval) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        minCompoundInterval = interval;\n    }\n    \n    // Operator management\n    function addOperator(address operator) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        grantRole(OPERATOR_ROLE, operator);\n        emit OperatorAdded(operator);\n    }\n    \n    function removeOperator(address operator) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        revokeRole(OPERATOR_ROLE, operator);\n        emit OperatorRemoved(operator);\n    }\n    \n    function addCompounder(address compounder) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        grantRole(COMPOUNDER_ROLE, compounder);\n    }\n    \n    function removeCompounder(address compounder) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        revokeRole(COMPOUNDER_ROLE, compounder);\n    }\n    \n    // ========================================\n    // STRATEGY MANAGEMENT\n    // ========================================\n    \n    function registerStrategy(\n        address strategy,\n        string calldata name\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(strategy != address(0), \"Invalid strategy address\");\n        require(!registeredStrategies[strategy], \"Strategy already registered\");\n        \n        registeredStrategies[strategy] = true;\n        strategyList.push(strategy);\n        strategyNames[strategy] = name;\n        \n        emit StrategyRegistered(strategy, name);\n    }\n    \n    function deregisterStrategy(address strategy) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(registeredStrategies[strategy], \"Strategy not registered\");\n        \n        registeredStrategies[strategy] = false;\n        delete strategyNames[strategy];\n        \n        emit StrategyDeregistered(strategy);\n    }\n    \n    // ========================================\n    // ALLOCATION VIEW FUNCTIONS\n    // ========================================\n    \n    function getCurrentAllocation(address vault) external view returns (\n        uint256 bufferAmount,\n        uint256 kineticAmount,\n        uint256 firelightAmount,\n        uint256 totalAssets\n    ) {\n        require(registeredVaults[vault], \"Vault not registered\");\n        \n        ShXRPVault vaultContract = ShXRPVault(vault);\n        IERC20 asset = IERC20(vaultContract.asset());\n        \n        bufferAmount = asset.balanceOf(address(vaultContract));\n        \n        for (uint256 i = 0; i < strategyList.length; i++) {\n            address strategyAddr = strategyList[i];\n            if (!registeredStrategies[strategyAddr]) continue;\n            \n            string memory name = strategyNames[strategyAddr];\n            uint256 strategyAssets = 0;\n            \n            try IStrategy(strategyAddr).totalAssets() returns (uint256 assets) {\n                strategyAssets = assets;\n            } catch {\n                strategyAssets = 0;\n            }\n            \n            if (keccak256(bytes(name)) == keccak256(bytes(\"Kinetic\"))) {\n                kineticAmount = strategyAssets;\n            } else if (keccak256(bytes(name)) == keccak256(bytes(\"Firelight\"))) {\n                firelightAmount = strategyAssets;\n            }\n        }\n        \n        totalAssets = bufferAmount + kineticAmount + firelightAmount;\n    }\n    \n    function getTargetAllocation(address vault, uint256 totalAssets) external view returns (\n        uint256 bufferTarget,\n        uint256 kineticTarget,\n        uint256 firelightTarget\n    ) {\n        require(registeredVaults[vault], \"Vault not registered\");\n        \n        address kineticStrategy = _getStrategyAddress(vault, \"Kinetic\");\n        address firelightStrategy = _getStrategyAddress(vault, \"Firelight\");\n        \n        bool kineticActive = _isStrategyActive(vault, kineticStrategy);\n        bool firelightActive = _isStrategyActive(vault, firelightStrategy);\n        \n        bufferTarget = (totalAssets * BUFFER_TARGET_BPS) / 10000;\n        \n        if (kineticActive && firelightActive) {\n            kineticTarget = (totalAssets * KINETIC_TARGET_BPS) / 10000;\n            firelightTarget = (totalAssets * FIRELIGHT_TARGET_BPS) / 10000;\n        } else if (kineticActive && !firelightActive) {\n            kineticTarget = (totalAssets * (KINETIC_TARGET_BPS + FIRELIGHT_TARGET_BPS)) / 10000;\n            firelightTarget = 0;\n        } else if (!kineticActive && firelightActive) {\n            kineticTarget = 0;\n            firelightTarget = (totalAssets * (KINETIC_TARGET_BPS + FIRELIGHT_TARGET_BPS)) / 10000;\n        } else {\n            bufferTarget = totalAssets;\n            kineticTarget = 0;\n            firelightTarget = 0;\n        }\n    }\n    \n    function needsRebalancing(\n        address vault,\n        uint256 thresholdBps\n    ) external view returns (bool) {\n        require(registeredVaults[vault], \"Vault not registered\");\n        \n        (\n            uint256 bufferAmount,\n            uint256 kineticAmount,\n            uint256 firelightAmount,\n            uint256 totalAssets\n        ) = this.getCurrentAllocation(vault);\n        \n        if (totalAssets == 0) return false;\n        \n        (uint256 bufferTarget, uint256 kineticTarget, uint256 firelightTarget) = \n            this.getTargetAllocation(vault, totalAssets);\n        \n        uint256 bufferDeviation = _calculateDeviation(bufferAmount, bufferTarget, totalAssets);\n        uint256 kineticDeviation = _calculateDeviation(kineticAmount, kineticTarget, totalAssets);\n        uint256 firelightDeviation = _calculateDeviation(firelightAmount, firelightTarget, totalAssets);\n        \n        return bufferDeviation > thresholdBps || \n               kineticDeviation > thresholdBps || \n               firelightDeviation > thresholdBps;\n    }\n    \n    function _calculateDeviation(\n        uint256 current,\n        uint256 target,\n        uint256 total\n    ) internal pure returns (uint256) {\n        if (total == 0) return 0;\n        \n        uint256 currentBps = (current * 10000) / total;\n        uint256 targetBps = (target * 10000) / total;\n        \n        if (currentBps > targetBps) {\n            return currentBps - targetBps;\n        } else {\n            return targetBps - currentBps;\n        }\n    }\n    \n    function _isStrategyActive(address vault, address strategy) internal view returns (bool) {\n        if (strategy == address(0)) return false;\n        \n        try ShXRPVault(vault).getStrategyInfo(strategy) returns (ShXRPVault.StrategyInfo memory info) {\n            return info.status == ShXRPVault.StrategyStatus.Active || \n                   info.status == ShXRPVault.StrategyStatus.Paused;\n        } catch {\n            return false;\n        }\n    }\n    \n    function _getStrategyAddress(address vault, string memory name) internal view returns (address) {\n        address strategy = _getStrategyByName(name);\n        if (strategy == address(0)) return address(0);\n        \n        try ShXRPVault(vault).getStrategyInfo(strategy) returns (ShXRPVault.StrategyInfo memory) {\n            return strategy;\n        } catch {\n            return address(0);\n        }\n    }\n    \n    // ========================================\n    // STRATEGY DEPLOYMENT FUNCTIONS\n    // ========================================\n    \n    /**\n     * @dev Calculate strategy deficits based on current and target allocations\n     * @param kineticCurrent Current Kinetic strategy balance\n     * @param firelightCurrent Current Firelight strategy balance\n     * @param kineticTarget Target Kinetic strategy balance\n     * @param firelightTarget Target Firelight strategy balance\n     * @return kineticDeficit Deficit for Kinetic (positive = underweight, negative = overweight)\n     * @return firelightDeficit Deficit for Firelight (positive = underweight, negative = overweight)\n     */\n    function _calculateStrategyDeficits(\n        uint256 kineticCurrent,\n        uint256 firelightCurrent,\n        uint256 kineticTarget,\n        uint256 firelightTarget\n    ) private pure returns (\n        int256 kineticDeficit,\n        int256 firelightDeficit\n    ) {\n        kineticDeficit = int256(kineticTarget) - int256(kineticCurrent);\n        firelightDeficit = int256(firelightTarget) - int256(firelightCurrent);\n    }\n    \n    /**\n     * @dev Calculate deployment amounts based on deficits\n     * @param deployableAmount Total amount available to deploy\n     * @param kineticCurrent Current Kinetic balance\n     * @param firelightCurrent Current Firelight balance\n     * @param totalAssets Current total assets\n     * @return kineticAmount Amount to deploy to Kinetic\n     * @return firelightAmount Amount to deploy to Firelight\n     */\n    function _calculateDeploymentAmounts(\n        address vault,\n        uint256 deployableAmount,\n        uint256 kineticCurrent,\n        uint256 firelightCurrent,\n        uint256 totalAssets\n    ) private view returns (\n        uint256 kineticAmount,\n        uint256 firelightAmount\n    ) {\n        // Calculate targets\n        (, uint256 kineticTarget, uint256 firelightTarget) = this.getTargetAllocation(vault, totalAssets);\n        \n        // Calculate deficits (can be negative)\n        int256 kineticDeficit = int256(kineticTarget) - int256(kineticCurrent);\n        int256 firelightDeficit = int256(firelightTarget) - int256(firelightCurrent);\n        \n        // ONLY allocate to underweight strategies\n        // CAP each at its positive deficit\n        \n        if (kineticDeficit > 0 && firelightDeficit > 0) {\n            // Both underweight - cap each at deficit\n            uint256 kineticNeed = uint256(kineticDeficit);\n            uint256 firelightNeed = uint256(firelightDeficit);\n            uint256 totalNeed = kineticNeed + firelightNeed;\n            \n            if (deployableAmount >= totalNeed) {\n                // Can satisfy both - cap at exact deficits\n                kineticAmount = kineticNeed;\n                firelightAmount = firelightNeed;\n                // Residual stays in buffer (deployableAmount - totalNeed)\n            } else {\n                // Can't satisfy both - proportional allocation\n                kineticAmount = deployableAmount * kineticNeed / totalNeed;\n                firelightAmount = deployableAmount - kineticAmount;\n                // No residual (used all deployable)\n            }\n            \n        } else if (kineticDeficit > 0) {\n            // Only Kinetic underweight\n            uint256 kineticNeed = uint256(kineticDeficit);\n            kineticAmount = deployableAmount < kineticNeed ? deployableAmount : kineticNeed;\n            firelightAmount = 0;  // NOT sending to overweight Firelight!\n            // Residual stays in buffer if deployableAmount > kineticNeed\n            \n        } else if (firelightDeficit > 0) {\n            // Only Firelight underweight\n            uint256 firelightNeed = uint256(firelightDeficit);\n            kineticAmount = 0;  // NOT sending to overweight Kinetic!\n            firelightAmount = deployableAmount < firelightNeed ? deployableAmount : firelightNeed;\n            // Residual stays in buffer if deployableAmount > firelightNeed\n            \n        } else {\n            // Both at or above target - cannot deploy\n            revert(\"Strategies already at or above target allocation\");\n        }\n    }\n    \n    /**\n     * @dev External wrapper for _calculateDeploymentAmounts to enable try/catch\n     */\n    function _calculateDeploymentAmountsExternal(\n        address vault,\n        uint256 deployableAmount,\n        uint256 kineticCurrent,\n        uint256 firelightCurrent,\n        uint256 totalAssets\n    ) external view returns (\n        uint256 kineticAmount,\n        uint256 firelightAmount\n    ) {\n        return _calculateDeploymentAmounts(\n            vault,\n            deployableAmount,\n            kineticCurrent,\n            firelightCurrent,\n            totalAssets\n        );\n    }\n    \n    function deployToStrategies(\n        address vault,\n        uint256 amount\n    ) external onlyRole(OPERATOR_ROLE) nonReentrant {\n        require(registeredVaults[vault], \"Vault not registered\");\n        \n        (uint256 bufferCurrent, uint256 kineticCurrent, uint256 firelightCurrent, uint256 totalAssets) \n            = this.getCurrentAllocation(vault);\n        \n        (uint256 bufferTarget, , ) = this.getTargetAllocation(vault, totalAssets);\n        \n        uint256 deployableAmount;\n        if (bufferCurrent > bufferTarget) {\n            deployableAmount = bufferCurrent - bufferTarget;\n        } else {\n            revert(\"Buffer already at or below target - cannot deploy\");\n        }\n        \n        if (amount > 0 && amount < deployableAmount) {\n            deployableAmount = amount;\n        }\n        \n        require(deployableAmount > 0, \"No funds available for deployment\");\n        require(bufferCurrent >= deployableAmount, \"Insufficient vault liquidity\");\n        \n        address kinetic = _getStrategyByName(\"Kinetic\");\n        address firelight = _getStrategyByName(\"Firelight\");\n        \n        require(kinetic != address(0), \"Kinetic strategy not registered\");\n        require(firelight != address(0), \"Firelight strategy not registered\");\n        \n        // Calculate deployment amounts (may be less than deployableAmount)\n        (uint256 kineticAmount, uint256 firelightAmount) = _calculateDeploymentAmounts(\n            vault,\n            deployableAmount,\n            kineticCurrent,\n            firelightCurrent,\n            totalAssets\n        );\n        \n        // IMPORTANT: Only deploy what was calculated (may leave residual in buffer)\n        // This is CORRECT behavior - buffer can be above 10% when strategies are at target\n        \n        if (kineticAmount > 0) {\n            ShXRPVault(vault).deployToStrategy(kinetic, kineticAmount);\n            emit StrategyDeployed(vault, kinetic, kineticAmount);\n        }\n        if (firelightAmount > 0) {\n            ShXRPVault(vault).deployToStrategy(firelight, firelightAmount);\n            emit StrategyDeployed(vault, firelight, firelightAmount);\n        }\n        \n        // Note: If kineticAmount + firelightAmount < deployableAmount, residual stays in buffer\n    }\n    \n    function withdrawFromStrategies(\n        address vault,\n        uint256 amount\n    ) external onlyRole(OPERATOR_ROLE) nonReentrant {\n        require(registeredVaults[vault], \"Vault not registered\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        \n        address kineticStrategy = _getStrategyByName(\"Kinetic\");\n        address firelightStrategy = _getStrategyByName(\"Firelight\");\n        \n        require(kineticStrategy != address(0) || firelightStrategy != address(0), \"No strategies registered\");\n        \n        uint256 kineticAvailable = 0;\n        uint256 firelightAvailable = 0;\n        \n        if (kineticStrategy != address(0)) {\n            try IStrategy(kineticStrategy).totalAssets() returns (uint256 assets) {\n                kineticAvailable = assets;\n            } catch {}\n        }\n        \n        if (firelightStrategy != address(0)) {\n            try IStrategy(firelightStrategy).totalAssets() returns (uint256 assets) {\n                firelightAvailable = assets;\n            } catch {}\n        }\n        \n        uint256 totalStrategyAssets = kineticAvailable + firelightAvailable;\n        require(totalStrategyAssets >= amount, \"Insufficient strategy liquidity\");\n        \n        ShXRPVault vaultContract = ShXRPVault(vault);\n        uint256 remainingToWithdraw = amount;\n        \n        if (firelightStrategy != address(0) && remainingToWithdraw > 0) {\n            if (firelightAvailable > 0) {\n                uint256 withdrawAmount = remainingToWithdraw > firelightAvailable ? firelightAvailable : remainingToWithdraw;\n                vaultContract.withdrawFromStrategy(firelightStrategy, withdrawAmount);\n                remainingToWithdraw -= withdrawAmount;\n                emit StrategyWithdrawn(vault, firelightStrategy, withdrawAmount);\n            }\n        }\n        \n        if (kineticStrategy != address(0) && remainingToWithdraw > 0) {\n            if (kineticAvailable > 0) {\n                uint256 withdrawAmount = remainingToWithdraw > kineticAvailable ? kineticAvailable : remainingToWithdraw;\n                vaultContract.withdrawFromStrategy(kineticStrategy, withdrawAmount);\n                remainingToWithdraw -= withdrawAmount;\n                emit StrategyWithdrawn(vault, kineticStrategy, withdrawAmount);\n            }\n        }\n        \n        require(remainingToWithdraw == 0 || remainingToWithdraw < amount, \"Insufficient liquidity in strategies\");\n    }\n    \n    function rebalanceVault(address vault) external onlyRole(OPERATOR_ROLE) nonReentrant {\n        require(registeredVaults[vault], \"Vault not registered\");\n        \n        (\n            uint256 bufferBefore,\n            uint256 kineticBefore,\n            uint256 firelightBefore,\n            uint256 totalAssets\n        ) = this.getCurrentAllocation(vault);\n        \n        if (totalAssets == 0) return;\n        \n        uint256 bufferTarget = (totalAssets * BUFFER_TARGET_BPS) / 10000;\n        \n        address kineticStrategy = _getStrategyByName(\"Kinetic\");\n        address firelightStrategy = _getStrategyByName(\"Firelight\");\n        \n        if (bufferBefore > bufferTarget) {\n            _rebalanceExcessBuffer(vault, bufferBefore - bufferTarget, kineticStrategy, firelightStrategy);\n        } else if (bufferBefore < bufferTarget) {\n            _rebalanceDeficitBuffer(vault, bufferTarget - bufferBefore, kineticBefore, firelightBefore, kineticStrategy, firelightStrategy, totalAssets);\n        }\n        \n        (\n            uint256 bufferAfter,\n            uint256 kineticAfter,\n            uint256 firelightAfter,\n        ) = this.getCurrentAllocation(vault);\n        \n        emit VaultRebalanced(\n            vault,\n            bufferBefore,\n            bufferAfter,\n            kineticBefore,\n            kineticAfter,\n            firelightBefore,\n            firelightAfter\n        );\n    }\n    \n    function _rebalanceExcessBuffer(\n        address vault,\n        uint256 excess,\n        address kinetic,\n        address firelight\n    ) internal {\n        (uint256 bufferCurrent, uint256 kineticCurrent, uint256 firelightCurrent, uint256 totalAssets) \n            = this.getCurrentAllocation(vault);\n        \n        (uint256 bufferTarget, , ) = this.getTargetAllocation(vault, totalAssets);\n        \n        uint256 deployableAmount;\n        if (bufferCurrent > bufferTarget) {\n            deployableAmount = bufferCurrent - bufferTarget;\n        } else {\n            return;\n        }\n        \n        if (excess < deployableAmount) {\n            deployableAmount = excess;\n        }\n        \n        require(bufferCurrent >= deployableAmount, \"Insufficient vault liquidity for rebalancing\");\n        \n        // Try to calculate deficit-driven deployment amounts\n        // If both strategies are at target, just return (no deployment needed)\n        uint256 kineticDeploy = 0;\n        uint256 firelightDeploy = 0;\n        \n        try this._calculateDeploymentAmountsExternal(\n            vault,\n            deployableAmount,\n            kineticCurrent,\n            firelightCurrent,\n            totalAssets\n        ) returns (uint256 k, uint256 f) {\n            kineticDeploy = k;\n            firelightDeploy = f;\n        } catch {\n            // Both strategies at or above target - nothing to deploy\n            return;\n        }\n        \n        if (kinetic != address(0) && kineticDeploy > 0) {\n            ShXRPVault(vault).deployToStrategy(kinetic, kineticDeploy);\n            emit StrategyDeployed(vault, kinetic, kineticDeploy);\n        }\n        \n        if (firelight != address(0) && firelightDeploy > 0) {\n            ShXRPVault(vault).deployToStrategy(firelight, firelightDeploy);\n            emit StrategyDeployed(vault, firelight, firelightDeploy);\n        }\n    }\n    \n    function _rebalanceDeficitBuffer(\n        address vault,\n        uint256 deficit,\n        uint256 kineticBefore,\n        uint256 firelightBefore,\n        address kineticStrategy,\n        address firelightStrategy,\n        uint256 totalAssets\n    ) internal {\n        ShXRPVault vaultContract = ShXRPVault(vault);\n        (, uint256 kineticTarget, uint256 firelightTarget) = this.getTargetAllocation(vault, totalAssets);\n        \n        if (firelightStrategy != address(0) && firelightBefore > firelightTarget) {\n            uint256 withdrawAmount = firelightBefore - firelightTarget;\n            if (withdrawAmount > deficit) withdrawAmount = deficit;\n            \n            vaultContract.withdrawFromStrategy(firelightStrategy, withdrawAmount);\n            deficit -= withdrawAmount;\n            emit StrategyWithdrawn(vault, firelightStrategy, withdrawAmount);\n        }\n        \n        if (kineticStrategy != address(0) && deficit > 0 && kineticBefore > kineticTarget) {\n            uint256 withdrawAmount = kineticBefore - kineticTarget;\n            if (withdrawAmount > deficit) withdrawAmount = deficit;\n            \n            vaultContract.withdrawFromStrategy(kineticStrategy, withdrawAmount);\n            emit StrategyWithdrawn(vault, kineticStrategy, withdrawAmount);\n        }\n    }\n    \n    function _getStrategyByName(string memory name) internal view returns (address) {\n        for (uint256 i = 0; i < strategyList.length; i++) {\n            if (registeredStrategies[strategyList[i]] && \n                keccak256(bytes(strategyNames[strategyList[i]])) == keccak256(bytes(name))) {\n                return strategyList[i];\n            }\n        }\n        return address(0);\n    }\n    \n    // ========================================\n    // VIEW FUNCTIONS\n    // ========================================\n    \n    function getBridgeRequest(bytes32 requestId) external view returns (BridgeRequest memory) {\n        return bridgeRequests[requestId];\n    }\n    \n    function getVaultCount() external view returns (uint256) {\n        return vaultList.length;\n    }\n    \n    function getStrategyCount() external view returns (uint256) {\n        return strategyList.length;\n    }\n}\n"
      }
    }
  }
}