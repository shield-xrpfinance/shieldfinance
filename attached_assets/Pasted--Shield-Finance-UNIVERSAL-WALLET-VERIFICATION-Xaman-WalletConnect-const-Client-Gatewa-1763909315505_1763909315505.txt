// Shield Finance — UNIVERSAL WALLET VERIFICATION (Xaman + WalletConnect)
const {
  Client,
  GatewayIntentBits,
  ChannelType,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle,
  SlashCommandBuilder,
} = require('discord.js');
const { ethers } = require('ethers');
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.GuildMembers,
  ],
});

const TOKEN = process.env.DISCORD_BOT_TOKEN;
const GUILD_ID = process.env.DISCORD_GUILD_ID;

const pending = new Map(); // userId → verification data

client.once('ready', async () => {
  console.log('Universal verification ready');

  const guild = client.guilds.cache.get(GUILD_ID);
  await guild.commands.set([
    new SlashCommandBuilder().setName('verify').setDescription('Verify with any wallet (Xaman or WalletConnect)'),
  ]);

  // Welcome button
  const welcome = guild.channels.cache.find(c => c.name === 'start-here');
  if (welcome) {
    await welcome.bulkDelete(20).catch(() => {});
    await welcome.send({
      content: '@everyone',
      embeds: [new EmbedBuilder()
        .setColor('#00FFAA')
        .setTitle('Verify Your Wallet — Works with Xaman & WalletConnect')
        .setDescription('Click the button or type `/verify`')],
      components: [new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('verify_btn').setLabel('Verify Wallet').setStyle(ButtonStyle.Success).setEmoji('Shield')
      )]
    });
  });
});

// Main entry point
client.on('interactionCreate', async i => {
  if (!i.isChatInputCommand() && !i.isButton()) return;
  if (i.commandName !== 'verify' && i.customId !== 'verify_btn') return;

  const row = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('xaman_verify').setLabel('Xaman / Classic Wallet').setStyle(ButtonStyle.Primary),
    new ButtonBuilder().setCustomId('wc_verify').setLabel('WalletConnect (MetaMask, Trust, etc.)').setStyle(ButtonStyle.Secondary)
  );

  await i.reply({
    content: 'Choose your wallet type:',
    components: [row],
    ephemeral: true
  });
});

// ——— CLASSIC XRPL (Xaman) ———
client.on('interactionCreate', async i => {
  if (i.customId === 'xaman_verify') {
    // Same modal flow as before
    const modal = new ModalBuilder().setCustomId('xaman_modal').setTitle('XRPL Address');
    modal.addComponents(new ActionRowBuilder().addComponents(
      new TextInputBuilder().setCustomId('addr').setLabel('r-address').setStyle(TextInputStyle.Short).setRequired(true)
    ));
    await i.showModal(modal);
  }

  if (i.customId === 'xaman_modal') {
    const address = i.fields.getTextInputValue('addr');
    const challenge = `Shield Finance verification ${Date.now()}-${i.user.id}`;
    pending.set(i.user.id, { type: 'xaman', address, challenge });

    await i.reply({
      content: `Sign this message in Xaman:\n\`\`\`${challenge}\`\`\`\nThen paste the signature in the next modal.`,
      ephemeral: true
    });

    const modal2 = new ModalBuilder().setCustomId('xaman_sig').setTitle('Paste Signature');
    modal2.addComponents(new ActionRowBuilder().addComponents(
      new TextInputBuilder().setCustomId('sig').setLabel('Signature').setStyle(TextInputStyle.Paragraph).setRequired(true)
    ));
    await i.showModal(modal2);
  }

  if (i.customId === 'xaman_sig') {
    const sig = i.fields.getTextInputValue('sig');
    const data = pending.get(i.user.id);
    // Simple verification via public XRPL node (good enough for Discord)
    const res = await fetch('https://s1.ripple.com:51234', {
      method: 'POST',
      body: JSON.stringify({
        method: 'verify',
        params: [{ message: data.challenge, signature: sig, address: data.address }]
      })
    }).then(r => r.json());

    if (res.result?.verified) {
      await giveRoles(i.member);
      await i.reply({ content: 'Verified with Xaman!', ephemeral: true });
    } else {
      await i.reply({ content: 'Invalid signature', ephemeral: true });
    }
    pending.delete(i.user.id);
  }
});

// ——— WALLET CONNECT (EVM sidechain) ———
client.on('interactionCreate', async i => {
  if (i.customId === 'wc_verify') {
    const nonce = Math.floor(Math.random() * 1e9);
    pending.set(i.user.id, { type: 'wc', nonce });

    const domain = { name: 'Shield Finance', version: '1', chainId: 1440002 }; // XRPL EVM sidechain
    const types = { Verify: [{ name: 'nonce', type: 'uint256' }] };
    const message = { nonce };

    const typedData = JSON.stringify({ domain, types, message, primaryType: 'Verify' });

    await i.reply({
      content: `Connect with WalletConnect & sign this message:\n\`\`\`json\n${typedData}\n\`\`\``,
      ephemeral: true
    });

    const modal = new ModalBuilder().setCustomId('wc_sig').setTitle('Paste Signed Message');
    modal.addComponents(new ActionRowBuilder().addComponents(
      new TextInputBuilder().setCustomId('signed').setLabel('Full JSON output from wallet').setStyle(TextInputStyle.Paragraph).setRequired(true)
    ));
    await i.showModal(modal);
  }

  if (i.customId === 'wc_sig') {
    const input = i.fields.getTextInputValue('signed');
    const data = pending.get(i.user.id);
    if (!data || data.type !== 'wc') return i.reply({ content: 'Expired', ephemeral: true });

    try {
      const parsed = JSON.parse(input);
      const recovered = ethers.verifyTypedData(
        parsed.domain,
        parsed.types,
        parsed.message,
        parsed.signature
      );
      // Optional: check balance on XRPL EVM sidechain via public RPC
      if (parsed.message.nonce === data.nonce) {
        await giveRoles(i.member);
        await i.reply({ content: 'WalletConnect verified!', ephemeral: true });
      }
    } catch {
      await i.reply({ content: 'Invalid signature', ephemeral: true });
    }
    pending.delete(i.user.id);
  }
});

async function giveRoles(member) {
  const roles = ['Shield Holder', 'Verified'].map(name => member.guild.roles.cache.find(r => r.name === name)).filter(Boolean);
  await member.roles.add(roles);
}

client.login(TOKEN);